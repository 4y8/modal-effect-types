-- stdlib : list ---------------------------------------------------------------

type list a = Nil | Cons of a, list a

-- stdlib : pair ---------------------------------------------------------------

type pair a b = Pair of a, b

-- stdlib : option -------------------------------------------------------------

type option a = None | Some of a

val option.map : forall a b . (a -> b) -> option a -> option b
let option.map f o =
  match o with
  | None -> None
  | Some (x) -> Some (f x)
  end

-- stdlib : bool ---------------------------------------------------------------

type bool = True | False

-- stdlib : unit ---------------------------------------------------------------

type unit = Unit

-- surface ---------------------------------------------------------------------

type surface
  = SVar of string
  | SLam of string, option surface, surface
  | SApp of surface, surface
  | SType
  | SPi of string, surface, surface
  | SAs of surface, surface

-- TT --------------------------------------------------------------------------

type tm
  = Var of int
  | Lam of int, tm, tm
  | App of tm, tm
  | Type
  | Pi of int, tm, tm
--  | Meta of int

-- value -----------------------------------------------------------------------

type head
  = HVar of int
  -- | HMeta of int

type value
  = VType
  | VPi of int, tm, tm
  | VLam of int, tm, tm
  | VSpine of head, list tm

-- state -----------------------------------------------------------------------
eff state
  = fresh_var : unit => int

val with_state : forall [a] . [](<state>{a} -> int -> a)
let with_state c =
  handle<state> c () with
  | return v => fun x -> v
  | fresh_var u k => fun x -> k x (x + 1)
  end

-- error -----------------------------------------------------------------------

eff error
  = unknown_var : string => forall [a] . a
  | cannot_infer_arg : string => forall [a] . a
  | expected_fun : value => forall [a] . a
  | type_mismatch : tm * tm => forall [a] . a
  | internal_error : unit => forall [a] . a

val with_print_error : forall [a] . [](<error>{a} -> a)
let with_print_error c =
  handle<error> c () with
  | return v => v
  | unknown_var v k => print ("error: unknown variable " ^ v); fail @a ()
  | cannot_infer_arg v k =>
    print ("error: cannot infer the type of the argument " ^ v);
    fail @a ()
  | expected_fun v k => print "error: expected a function"; fail @a ()
  | type_mismatch p k => print "error: type mismatch"; fail @a ()
  | internal_error u k =>
    print "error: internal failure (shouldn't happen)"; fail @a ()
  end

-- context ---------------------------------------------------------------------

eff context
  = lookup_var : int => tm
  | lookup_id : string => int
--  | lookup_meta : int => (option tm * tm)
--  | fresh_meta : tm => tm
--  | set_meta : int * tm => bool

val with_bind : forall [a] . [context](int -> tm -> <context>{a} -> a)
let with_bind x t c =
  handle<context> c () with
  | return v => v
  | lookup_var y k =>
    if y = x then
      k t
    else
      k (do lookup_var y)
  | lookup_id v k => k (do lookup_id v)
  end

val with_id : forall [a] . [state, context](string -> tm -> <context>(int -> a) -> a)
let with_id v t c =
  let x = do fresh_var () in
  handle<context> c x with
  | return v => v
  | lookup_var y k =>
    if y = x then
      k t
    else
      k (do lookup_var y)
  | lookup_id w k =>
    if string_eq v w then
      k x
    else
      k (do lookup_id w)
  end

val with_empty_context : forall [a] . [error](<context>{a} -> a)
let with_empty_context c =
  handle<context> c () with
  | return v => v
  | lookup_var y k => (do internal_error ()) @ a
  | lookup_id v k => (do unknown_var v) @ a
  end

-- subst -----------------------------------------------------------------------

val lookup : [](int -> list (int * tm) -> option tm)
let lookup x l =
  match l with
  | Nil -> None
  | Cons ((y, m), tl) ->
    if x = y then Some (m) else lookup x tl
  end

val subst : [state](list (int * tm) -> tm -> tm)
let subst s m =
  match m with
  | Var (x) ->
    match lookup x s with
    | None -> m
    | Some (n) -> n
    end
  | Lam (x, t, m) ->
    let y = do fresh_var () in
    Lam (y, subst s t, subst (Cons ((x, Var (y)), s)) m)
  | Type -> Type
  | Pi (x, t, m) ->
    let y = do fresh_var () in
    Pi (y, subst s t, subst (Cons ((x, Var (y)), s)) m)
  end

val subst_single : [state](int -> tm -> tm -> tm)
let subst_single x m =
  subst (Cons ((x, m), Nil))

-- norm ------------------------------------------------------------------------

val norm_tm' : [state](tm -> tm)
let norm_tm' m =
  match m with
  | Type -> Type
  | Var (_) -> m
  | Pi (_, _, _) -> m
  | Lam (_, _, _) -> m
  | App (m, n) ->
    match norm_tm' m with
    | Lam (x, _, e) -> norm_tm' (subst_single x n e)
    | e -> App (e, n)
    end
  end

val fold_spine : (tm -> list tm -> head * list tm)
let fold_spine m sp =
  match m with
  | Var (x) -> (HVar (x), sp)
  | App (m, n) -> fold_spine m (Cons (n, sp))
  end

val norm_tm : [state](tm -> value)
let norm_tm e =
  match norm_tm' e with
  | Type -> VType
  | Pi (x, t, t') -> VPi (x, t, t')
  | Lam (x, t, m) -> VLam (x, t, m)
  | m ->
    let (h, sp) = fold_spine m Nil in
    VSpine (h, sp)
  end

-- equal -----------------------------------------------------------------------

val equal_at : [state, context](tm -> tm -> tm -> bool)
val equal_tm : [state, context](tm -> tm -> bool)
val equal_sp : [state, context](head -> list tm -> head -> list tm -> bool)
val equal_sp_fold : [state, context](tm -> list tm -> list tm -> bool)

let equal_at m n t =
  match norm_tm t with
  | VPi (x, t, u) ->
    with_bind @bool x t {equal_at (App (m, Var (x))) (App (n, Var (x))) u}
  | VSpine (_, _) -> equal_tm m n
  | VType -> equal_tm m n
  end

let equal_tm m n =
  let p : (value * value) = (norm_tm m, norm_tm n) in
  match p with
  | VType, VType -> True
  | VPi (x, t, u), VPi (x', t', u') ->
    equal_at t t' Type &&
    with_bind @bool x t {equal_at u (subst_single x' (Var (x)) u') Type}
  | VSpine (hd, sp), VSpine (hd', sp') ->
    equal_sp hd sp hd' sp'
  | _, _ -> False
  end

val equal_hd : head -> head -> bool
let equal_hd hd hd' =
  let p : head * head = (hd, hd') in
  match p with
  | HVar (x), HVar (x') -> x = x'
  end

let equal_sp_fold t sp sp' =
  let p : list tm * list tm = (sp, sp') in
  match p with
  | Nil, Nil -> True
  | Nil, _ -> False
  | _, Nil -> False
  | Cons (m, sp), Cons (m', sp') ->
    match norm_tm t with
    | VPi (x, t, u) ->
      equal_at m m' t && equal_sp_fold (subst_single x m u) sp sp'
    | _ -> False
    end
  end

let equal_sp h sp h' sp' =
  equal_hd h h' &&
  match h with
  | HVar (x) -> equal_sp_fold (do lookup_var x) sp sp'
  end

-- typecheck -------------------------------------------------------------------

val infer : [context, state, error](surface -> tm * tm)
val check : [context, state, error](surface -> tm -> tm)

let infer e =
  match e with
  | SType -> (Type, Type)
  | SVar (v) ->
    let x = do lookup_id v in
    (Var (x), do lookup_var x)
  | SPi (v, t, u) ->
    let t = check t Type in
    with_id @(tm * tm) v t
      (fun x -> (Pi (x, t, check u Type), Type))
  | SLam (v, Some (t), e) ->
    let t = check t Type in
    with_id @(tm * tm) v t
      (fun x -> let (e, u) = infer e in
                (Lam (x, t, e), Pi (x, t, u)))
  | SLam (x, None, _) -> (do cannot_infer_arg x) @ (tm * tm)
  | SAs (m, t) ->
    let t = check t Type in
    (check m t, t)
  | SApp (m, n) ->
    let (m, t) = infer m in
    match norm_tm t with
    | VPi (x, t, u) ->
      let n = check n u in
      (App (m, n), subst_single x n u)
    | t -> (do expected_fun t) @ (tm * tm)
    end
  end

let check e t =
  match e with
  | SLam (v, None, m) ->
    match norm_tm t with
    | VPi (y, t, u) ->
      with_id @(tm) v t
      (fun x ->
        Lam (x, t, check m (subst_single y (Var (x)) u)))
    | t -> (do expected_fun t) @ tm
    end
  | _ ->
    let e, t' = infer e in
    if equal_at t t' Type then
      e
    else
      (do type_mismatch (t, t')) @ tm
  end

val top_level : forall [a] . [](<state, context, error>{a} -> a)
let top_level c =
  with_print_error @a {with_empty_context @a {with_state @a c 0}}

val check_top_level : [](surface -> tm -> tm)
let check_top_level s t =
  top_level @tm {check s t}

val infer_top_level : [](surface -> tm * tm)
let infer_top_level s =
  top_level @(tm * tm) {infer s}

val main : [](unit -> unit)
let main u =
  let _ =
    check_top_level (SLam ("A", None, SLam ("x", None, SVar ("x"))))
                    (Pi (0, Type, Pi (1, Var (0), Var (0)))) in
  ()
